# All kinds of Tracing vs Profiling
То есть смотри тут сам трейсинг даже делится на понятия:
1) Distributed Tracing - это трейсинг внутри приложения или группы приложений, инструктируем когда код пишем
2) eBPF tracing - можем трейсить от  приложения до ядра и устройств, но специфично по событиям которые сами определяем
3) Stack tracing - это трейсинг вызова функций внутри отдельного приложения

Где используем:
1) Distributed tracing - часто используем когда хотим понять где в микросервесной архитектуре у нас конкретно сбоит ( это может быть база или кеш Redis или скорость сети)
2) eBPF - нас волнует как система работает на специфическом ядре/хосте/системе/дисках/устройстве
3) Stack tracing - часто интерпретируемые языки из коробки имеют когда ошибки при исключениях возвращают

## Stack tracing vs Profiling
 - профили собираются с периодичностью
 - В основном профили нам показывают потреблением cpu, а трейсинг время выполнения запроса, функции, которые там много чего включает
 - stack tracing врят ли будет включать в себя memory дампы
 - Wall-clock profiling точно здесь не будет

## eBPF profiling vs non-eBPF Profiling
- Мы можем вставать на определённый вызов и собирать стек трейс от него, и аггрегировать количество и распределение стек трейсов без особой инструментации приложения
- Мы можем встать на finish_task_switch (системные вызовы) у ядра и отслеживать все свитчи интересующего нас процесса/потока, а также причину (ожидание futex, mutex, i/o или плановый свитч) и их длительность (wait).
- Мы можем отслеживать как эффективно работает наша программа в отношении состояния системы (во множестве других процессов), работы ядра (аллокация памяти, фрагментация) и устройств (задержки ввода вывода, работа сети, файловая система).
- Из-за того что ebpf это неинструктируемый код, могут быть сложности в определенных условиях с опред языками
